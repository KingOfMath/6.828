首先确认在mem_init()函数之前，页表状态：
页表是entrypgdir里定义的那个4M的，把物理地址[[0, 4M) 映射到 虚拟地址 [0, 4M) 和 [KERNBASE, KERNBASE + 4M)。
也就是说，在我们构造好新的页表，enable它之前，我们可用的地址空间就4M。

这也是为什么bootalloc要检查是否分配了超过4M的原因。
boot _ alloc 函数只被用来分配2个东西：pgdir（大小为4096K，我们马上就是填充这个一级页表），page数组（你算算就知道不会超过4M，qemu只给了128M的物理地址）。

另外值得注意的是pageinit()函数，这个函数把page数组和所有可用物理页都映射起来了。
再回去看看walk pgdir那个函数，可以看到分配新的二级页表调用的是 page alloc函数。
我们上面分析过为啥page_alloc 分配的页物理地址都小于4M了，这里就不说了。

而宏里的啥KADDR PADDR也是用在这个entrypgdir上的，特别的，如果想知道page数组的物理地址，就要用这个宏。

meminit函数做的事情，主要就是，我们现在这个4M的entrypgdir不够用啊，啥都没有。
所以，创建一个新的页表映射，当然和xv6一样，只负责内核部分（更准确的，UTOP上方的部分）。
我们Part3写的代码就是这个过程。因为映射的部分都是UTOP以上的，根据注释，我们应该用boot _map_ region 函数去映射。



虚拟内存
当 cpu 拿到一个地址并根据地址访问内存时，在 x86架构下药经过至少两级的地址变换：段式变换和页式变换。分段机制的主要目的是将代码段、数据段以及堆栈段分开，保证互不干扰。分页机制则是为了实现虚拟内存。
虚拟内存主要的好处是：

让每个程序都以为自己独占计算机内存空间，概念清晰，方便程序的编译和装载。
通过将部分内存暂存在磁盘上，可以让程序使用比物理内存大得多的虚拟内存，突破物理内存的限制。
通过对不同进程设置不同页表，可以防止进程访问其他进程的地址空间。通过在不同进程之间映射相同的物理页，又可以提供进程间的共享。
虚拟、线性和物理地址

虚拟地址
最原始的地址，也是 C/C++ 指针使用的地址。由前 16bit 段 (segment) 选择器和后 32bit 段内的偏移 (offset) 组成，显然一个段大小为 4GB。通过虚拟地址可以获得线性地址。
线性地址
前 10bit 为页目录项(page directory entry, PDE)，即该地址在页目录中的索引。中间 10bit 为页表项(page table entry, PTE)，代表在页表中的索引，最后 12bit 为偏移，也就是每页 4kB。通过线性地址可以获得物理地址。
物理地址
经过段转换以及页面转换，最终在 RAM 的硬件总线上的地址。

在 JOS 中，由于只有一个段，所以虚拟地址数值上等于线性地址。
JOS 内核常常需要读取或更改仅知道物理地址的内存。例如，添加一个到页表的映射要求分配物理内存来存储页目录并初始化内存。然而，内核和其他任何程序一样，无法绕过虚拟内存转换这个步骤，因此不能直接使用物理地址。JOS 将从 0x00000000 开始的物理内存映射到 0xf0000000 的其中一个原因就是需要使内核能读写仅知道物理地址的内存。为了把物理地址转为虚拟地址，内核需要给物理地址加上 0xf0000000。这就是 KADDR 函数做的事。
同样，JOS 内核有时也需要从虚拟地址获得物理地址。内核的全局变量和由 boot_alloc 分配的内存都在内核被加载的区域，即从0xf0000000开始的地方。因此，若需要将虚拟地址转为物理地址，直接减去0xf0000000即可。这就是 PADDR 函数做的事。

TODO: 尤其注意，在页目录项、页表项中存储的是页表项的物理地址前 20bit 外加 12bit 的 flag。