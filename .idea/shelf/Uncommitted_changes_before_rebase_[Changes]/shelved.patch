Index: kern/env.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* See COPYRIGHT for copyright information. */\n\n#include <inc/x86.h>\n#include <inc/mmu.h>\n#include <inc/error.h>\n#include <inc/string.h>\n#include <inc/assert.h>\n#include <inc/elf.h>\n\n#include <kern/env.h>\n#include <kern/pmap.h>\n#include <kern/trap.h>\n#include <kern/monitor.h>\n\nstruct Env *envs = NULL;\t\t// All environments\nstruct Env *curenv = NULL;\t\t// The current env\nstatic struct Env *env_free_list;\t// Free environment list\n\t\t\t\t\t// (linked by Env->env_link)\n\n#define ENVGENSHIFT\t12\t\t// >= LOGNENV\n\n// Global descriptor table.\n//\n// Set up global descriptor table (GDT) with separate segments for\n// kernel mode and user mode.  Segments serve many purposes on the x86.\n// We don't use any of their memory-mapping capabilities, but we need\n// them to switch privilege levels. \n//\n// The kernel and user segments are identical except for the DPL.\n// To load the SS register, the CPL must equal the DPL.  Thus,\n// we must duplicate the segments for the user and the kernel.\n//\n// In particular, the last argument to the SEG macro used in the\n// definition of gdt specifies the Descriptor Privilege Level (DPL)\n// of that descriptor: 0 for kernel and 3 for user.\n//\nstruct Segdesc gdt[] =\n{\n\t// 0x0 - unused (always faults -- for trapping NULL far pointers)\n\tSEG_NULL,\n\n\t// 0x8 - kernel code segment\n\t[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0),\n\n\t// 0x10 - kernel data segment\n\t[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0),\n\n\t// 0x18 - user code segment\n\t[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3),\n\n\t// 0x20 - user data segment\n\t[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3),\n\n\t// 0x28 - tss, initialized in trap_init_percpu()\n\t[GD_TSS0 >> 3] = SEG_NULL\n};\n\nstruct Pseudodesc gdt_pd = {\n\tsizeof(gdt) - 1, (unsigned long) gdt\n};\n\n//\n// Converts an envid to an env pointer.\n// If checkperm is set, the specified environment must be either the\n// current environment or an immediate child of the current environment.\n//\n// RETURNS\n//   0 on success, -E_BAD_ENV on error.\n//   On success, sets *env_store to the environment.\n//   On error, sets *env_store to NULL.\n//\nint\nenvid2env(envid_t envid, struct Env **env_store, bool checkperm)\n{\n\tstruct Env *e;\n\n\t// If envid is zero, return the current environment.\n\tif (envid == 0) {\n\t\t*env_store = curenv;\n\t\treturn 0;\n\t}\n\n\t// Look up the Env structure via the index part of the envid,\n\t// then check the env_id field in that struct Env\n\t// to ensure that the envid is not stale\n\t// (i.e., does not refer to a _previous_ environment\n\t// that used the same slot in the envs[] array).\n\te = &envs[ENVX(envid)];\n\tif (e->env_status == ENV_FREE || e->env_id != envid) {\n\t\t*env_store = 0;\n\t\treturn -E_BAD_ENV;\n\t}\n\n\t// Check that the calling environment has legitimate permission\n\t// to manipulate the specified environment.\n\t// If checkperm is set, the specified environment\n\t// must be either the current environment\n\t// or an immediate child of the current environment.\n\tif (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {\n\t\t*env_store = 0;\n\t\treturn -E_BAD_ENV;\n\t}\n\n\t*env_store = e;\n\treturn 0;\n}\n\n// Mark all environments in 'envs' as free, set their env_ids to 0,\n// and insert them into the env_free_list.\n// Make sure the environments are in the free list in the same order\n// they are in the envs array (i.e., so that the first call to\n// env_alloc() returns envs[0]).\n//\nvoid\nenv_init(void)\n{\n\t// Set up envs array\n\t// LAB 3: Your code here.\n\n\t// Per-CPU part of the initialization\n\tenv_init_percpu();\n}\n\n// Load GDT and segment descriptors.\nvoid\nenv_init_percpu(void)\n{\n\tlgdt(&gdt_pd);\n\t// The kernel never uses GS or FS, so we leave those set to\n\t// the user data segment.\n\tasm volatile(\"movw %%ax,%%gs\" : : \"a\" (GD_UD|3));\n\tasm volatile(\"movw %%ax,%%fs\" : : \"a\" (GD_UD|3));\n\t// The kernel does use ES, DS, and SS.  We'll change between\n\t// the kernel and user data segments as needed.\n\tasm volatile(\"movw %%ax,%%es\" : : \"a\" (GD_KD));\n\tasm volatile(\"movw %%ax,%%ds\" : : \"a\" (GD_KD));\n\tasm volatile(\"movw %%ax,%%ss\" : : \"a\" (GD_KD));\n\t// Load the kernel text segment into CS.\n\tasm volatile(\"ljmp %0,$1f\\n 1:\\n\" : : \"i\" (GD_KT));\n\t// For good measure, clear the local descriptor table (LDT),\n\t// since we don't use it.\n\tlldt(0);\n}\n\n//\n// Initialize the kernel virtual memory layout for environment e.\n// Allocate a page directory, set e->env_pgdir accordingly,\n// and initialize the kernel portion of the new environment's address space.\n// Do NOT (yet) map anything into the user portion\n// of the environment's virtual address space.\n//\n// Returns 0 on success, < 0 on error.  Errors include:\n//\t-E_NO_MEM if page directory or table could not be allocated.\n//\nstatic int\nenv_setup_vm(struct Env *e)\n{\n\tint i;\n\tstruct PageInfo *p = NULL;\n\n\t// Allocate a page for the page directory\n\tif (!(p = page_alloc(ALLOC_ZERO)))\n\t\treturn -E_NO_MEM;\n\n\t// Now, set e->env_pgdir and initialize the page directory.\n\t//\n\t// Hint:\n\t//    - The VA space of all envs is identical above UTOP\n\t//\t(except at UVPT, which we've set below).\n\t//\tSee inc/memlayout.h for permissions and layout.\n\t//\tCan you use kern_pgdir as a template?  Hint: Yes.\n\t//\t(Make sure you got the permissions right in Lab 2.)\n\t//    - The initial VA below UTOP is empty.\n\t//    - You do not need to make any more calls to page_alloc.\n\t//    - Note: In general, pp_ref is not maintained for\n\t//\tphysical pages mapped only above UTOP, but env_pgdir\n\t//\tis an exception -- you need to increment env_pgdir's\n\t//\tpp_ref for env_free to work correctly.\n\t//    - The functions in kern/pmap.h are handy.\n\n\t// LAB 3: Your code here.\n\n\t// UVPT maps the env's own page table read-only.\n\t// Permissions: kernel R, user R\n\te->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;\n\n\treturn 0;\n}\n\n//\n// Allocates and initializes a new environment.\n// On success, the new environment is stored in *newenv_store.\n//\n// Returns 0 on success, < 0 on failure.  Errors include:\n//\t-E_NO_FREE_ENV if all NENV environments are allocated\n//\t-E_NO_MEM on memory exhaustion\n//\nint\nenv_alloc(struct Env **newenv_store, envid_t parent_id)\n{\n\tint32_t generation;\n\tint r;\n\tstruct Env *e;\n\n\tif (!(e = env_free_list))\n\t\treturn -E_NO_FREE_ENV;\n\n\t// Allocate and set up the page directory for this environment.\n\tif ((r = env_setup_vm(e)) < 0)\n\t\treturn r;\n\n\t// Generate an env_id for this environment.\n\tgeneration = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);\n\tif (generation <= 0)\t// Don't create a negative env_id.\n\t\tgeneration = 1 << ENVGENSHIFT;\n\te->env_id = generation | (e - envs);\n\n\t// Set the basic status variables.\n\te->env_parent_id = parent_id;\n\te->env_type = ENV_TYPE_USER;\n\te->env_status = ENV_RUNNABLE;\n\te->env_runs = 0;\n\n\t// Clear out all the saved register state,\n\t// to prevent the register values\n\t// of a prior environment inhabiting this Env structure\n\t// from \"leaking\" into our new environment.\n\tmemset(&e->env_tf, 0, sizeof(e->env_tf));\n\n\t// Set up appropriate initial values for the segment registers.\n\t// GD_UD is the user data segment selector in the GDT, and\n\t// GD_UT is the user text segment selector (see inc/memlayout.h).\n\t// The low 2 bits of each segment register contains the\n\t// Requestor Privilege Level (RPL); 3 means user mode.  When\n\t// we switch privilege levels, the hardware does various\n\t// checks involving the RPL and the Descriptor Privilege Level\n\t// (DPL) stored in the descriptors themselves.\n\te->env_tf.tf_ds = GD_UD | 3;\n\te->env_tf.tf_es = GD_UD | 3;\n\te->env_tf.tf_ss = GD_UD | 3;\n\te->env_tf.tf_esp = USTACKTOP;\n\te->env_tf.tf_cs = GD_UT | 3;\n\t// You will set e->env_tf.tf_eip later.\n\n\t// commit the allocation\n\tenv_free_list = e->env_link;\n\t*newenv_store = e;\n\n\tcprintf(\"[%08x] new env %08x\\n\", curenv ? curenv->env_id : 0, e->env_id);\n\treturn 0;\n}\n\n//\n// Allocate len bytes of physical memory for environment env,\n// and map it at virtual address va in the environment's address space.\n// Does not zero or otherwise initialize the mapped pages in any way.\n// Pages should be writable by user and kernel.\n// Panic if any allocation attempt fails.\n//\nstatic void\nregion_alloc(struct Env *e, void *va, size_t len)\n{\n\t// LAB 3: Your code here.\n\t// (But only if you need it for load_icode.)\n\t//\n\t// Hint: It is easier to use region_alloc if the caller can pass\n\t//   'va' and 'len' values that are not page-aligned.\n\t//   You should round va down, and round (va + len) up.\n\t//   (Watch out for corner-cases!)\n}\n\n//\n// Set up the initial program binary, stack, and processor flags\n// for a user process.\n// This function is ONLY called during kernel initialization,\n// before running the first user-mode environment.\n//\n// This function loads all loadable segments from the ELF binary image\n// into the environment's user memory, starting at the appropriate\n// virtual addresses indicated in the ELF program header.\n// At the same time it clears to zero any portions of these segments\n// that are marked in the program header as being mapped\n// but not actually present in the ELF file - i.e., the program's bss section.\n//\n// All this is very similar to what our boot loader does, except the boot\n// loader also needs to read the code from disk.  Take a look at\n// boot/main.c to get ideas.\n//\n// Finally, this function maps one page for the program's initial stack.\n//\n// load_icode panics if it encounters problems.\n//  - How might load_icode fail?  What might be wrong with the given input?\n//\nstatic void\nload_icode(struct Env *e, uint8_t *binary)\n{\n\t// Hints:\n\t//  Load each program segment into virtual memory\n\t//  at the address specified in the ELF segment header.\n\t//  You should only load segments with ph->p_type == ELF_PROG_LOAD.\n\t//  Each segment's virtual address can be found in ph->p_va\n\t//  and its size in memory can be found in ph->p_memsz.\n\t//  The ph->p_filesz bytes from the ELF binary, starting at\n\t//  'binary + ph->p_offset', should be copied to virtual address\n\t//  ph->p_va.  Any remaining memory bytes should be cleared to zero.\n\t//  (The ELF header should have ph->p_filesz <= ph->p_memsz.)\n\t//  Use functions from the previous lab to allocate and map pages.\n\t//\n\t//  All page protection bits should be user read/write for now.\n\t//  ELF segments are not necessarily page-aligned, but you can\n\t//  assume for this function that no two segments will touch\n\t//  the same virtual page.\n\t//\n\t//  You may find a function like region_alloc useful.\n\t//\n\t//  Loading the segments is much simpler if you can move data\n\t//  directly into the virtual addresses stored in the ELF binary.\n\t//  So which page directory should be in force during\n\t//  this function?\n\t//\n\t//  You must also do something with the program's entry point,\n\t//  to make sure that the environment starts executing there.\n\t//  What?  (See env_run() and env_pop_tf() below.)\n\n\t// LAB 3: Your code here.\n\n\t// Now map one page for the program's initial stack\n\t// at virtual address USTACKTOP - PGSIZE.\n\n\t// LAB 3: Your code here.\n}\n\n//\n// Allocates a new env with env_alloc, loads the named elf\n// binary into it with load_icode, and sets its env_type.\n// This function is ONLY called during kernel initialization,\n// before running the first user-mode environment.\n// The new env's parent ID is set to 0.\n//\nvoid\nenv_create(uint8_t *binary, enum EnvType type)\n{\n\t// LAB 3: Your code here.\n}\n\n//\n// Frees env e and all memory it uses.\n//\nvoid\nenv_free(struct Env *e)\n{\n\tpte_t *pt;\n\tuint32_t pdeno, pteno;\n\tphysaddr_t pa;\n\n\t// If freeing the current environment, switch to kern_pgdir\n\t// before freeing the page directory, just in case the page\n\t// gets reused.\n\tif (e == curenv)\n\t\tlcr3(PADDR(kern_pgdir));\n\n\t// Note the environment's demise.\n\tcprintf(\"[%08x] free env %08x\\n\", curenv ? curenv->env_id : 0, e->env_id);\n\n\t// Flush all mapped pages in the user portion of the address space\n\tstatic_assert(UTOP % PTSIZE == 0);\n\tfor (pdeno = 0; pdeno < PDX(UTOP); pdeno++) {\n\n\t\t// only look at mapped page tables\n\t\tif (!(e->env_pgdir[pdeno] & PTE_P))\n\t\t\tcontinue;\n\n\t\t// find the pa and va of the page table\n\t\tpa = PTE_ADDR(e->env_pgdir[pdeno]);\n\t\tpt = (pte_t*) KADDR(pa);\n\n\t\t// unmap all PTEs in this page table\n\t\tfor (pteno = 0; pteno <= PTX(~0); pteno++) {\n\t\t\tif (pt[pteno] & PTE_P)\n\t\t\t\tpage_remove(e->env_pgdir, PGADDR(pdeno, pteno, 0));\n\t\t}\n\n\t\t// free the page table itself\n\t\te->env_pgdir[pdeno] = 0;\n\t\tpage_decref(pa2page(pa));\n\t}\n\n\t// free the page directory\n\tpa = PADDR(e->env_pgdir);\n\te->env_pgdir = 0;\n\tpage_decref(pa2page(pa));\n\n\t// return the environment to the free list\n\te->env_status = ENV_FREE;\n\te->env_link = env_free_list;\n\tenv_free_list = e;\n}\n\n//\n// Frees environment e.\n//\nvoid\nenv_destroy(struct Env *e)\n{\n\tenv_free(e);\n\n\tcprintf(\"Destroyed the only environment - nothing more to do!\\n\");\n\twhile (1)\n\t\tmonitor(NULL);\n}\n\n\n//\n// Restores the register values in the Trapframe with the 'iret' instruction.\n// This exits the kernel and starts executing some environment's code.\n//\n// This function does not return.\n//\nvoid\nenv_pop_tf(struct Trapframe *tf)\n{\n\tasm volatile(\n\t\t\"\\tmovl %0,%%esp\\n\"\n\t\t\"\\tpopal\\n\"\n\t\t\"\\tpopl %%es\\n\"\n\t\t\"\\tpopl %%ds\\n\"\n\t\t\"\\taddl $0x8,%%esp\\n\" /* skip tf_trapno and tf_errcode */\n\t\t\"\\tiret\\n\"\n\t\t: : \"g\" (tf) : \"memory\");\n\tpanic(\"iret failed\");  /* mostly to placate the compiler */\n}\n\n//\n// Context switch from curenv to env e.\n// Note: if this is the first call to env_run, curenv is NULL.\n//\n// This function does not return.\n//\nvoid\nenv_run(struct Env *e)\n{\n\t// Step 1: If this is a context switch (a new environment is running):\n\t//\t   1. Set the current environment (if any) back to\n\t//\t      ENV_RUNNABLE if it is ENV_RUNNING (think about\n\t//\t      what other states it can be in),\n\t//\t   2. Set 'curenv' to the new environment,\n\t//\t   3. Set its status to ENV_RUNNING,\n\t//\t   4. Update its 'env_runs' counter,\n\t//\t   5. Use lcr3() to switch to its address space.\n\t// Step 2: Use env_pop_tf() to restore the environment's\n\t//\t   registers and drop into user mode in the\n\t//\t   environment.\n\n\t// Hint: This function loads the new environment's state from\n\t//\te->env_tf.  Go back through the code you wrote above\n\t//\tand make sure you have set the relevant parts of\n\t//\te->env_tf to sensible values.\n\n\t// LAB 3: Your code here.\n\n\tpanic(\"env_run not yet implemented\");\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/kern/env.c b/kern/env.c
--- a/kern/env.c	(revision a9d7717cc4b7751b1ce8dca4e5aa2722fa617f6b)
+++ b/kern/env.c	(date 1637154938519)
@@ -116,7 +116,10 @@
 {
 	// Set up envs array
 	// LAB 3: Your code here.
-
+    for (int i = 0; i < ; ++i) {
+        
+    }
+    
 	// Per-CPU part of the initialization
 	env_init_percpu();
 }
Index: inc/env.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* See COPYRIGHT for copyright information. */\n\n#ifndef JOS_INC_ENV_H\n#define JOS_INC_ENV_H\n\n#include <inc/types.h>\n#include <inc/trap.h>\n#include <inc/memlayout.h>\n\ntypedef int32_t envid_t;\n\n// An environment ID 'envid_t' has three parts:\n//\n// +1+---------------21-----------------+--------10--------+\n// |0|          Uniqueifier             |   Environment    |\n// | |                                  |      Index       |\n// +------------------------------------+------------------+\n//                                       \\--- ENVX(eid) --/\n//\n// The environment index ENVX(eid) equals the environment's index in the\n// 'envs[]' array.  The uniqueifier distinguishes environments that were\n// created at different times, but share the same environment index.\n//\n// All real environments are greater than 0 (so the sign bit is zero).\n// envid_ts less than 0 signify errors.  The envid_t == 0 is special, and\n// stands for the current environment.\n\n#define LOG2NENV\t\t10\n#define NENV\t\t\t(1 << LOG2NENV)\n#define ENVX(envid)\t\t((envid) & (NENV - 1))\n\n// Values of env_status in struct Env\nenum {\n\tENV_FREE = 0,\n\tENV_DYING,\n\tENV_RUNNABLE,\n\tENV_RUNNING,\n\tENV_NOT_RUNNABLE\n};\n\n// Special environment types\nenum EnvType {\n\tENV_TYPE_USER = 0,\n};\n\nstruct Env {\n\tstruct Trapframe env_tf;\t// Saved registers\n\tstruct Env *env_link;\t\t// Next free Env\n\tenvid_t env_id;\t\t\t// Unique environment identifier\n\tenvid_t env_parent_id;\t\t// env_id of this env's parent\n\tenum EnvType env_type;\t\t// Indicates special system environments\n\tunsigned env_status;\t\t// Status of the environment\n\tuint32_t env_runs;\t\t// Number of times environment has run\n\n\t// Address space\n\tpde_t *env_pgdir;\t\t// Kernel virtual address of page dir\n};\n\n#endif // !JOS_INC_ENV_H\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inc/env.h b/inc/env.h
--- a/inc/env.h	(revision a9d7717cc4b7751b1ce8dca4e5aa2722fa617f6b)
+++ b/inc/env.h	(date 1637155032481)
@@ -44,7 +44,8 @@
 };
 
 struct Env {
-	struct Trapframe env_tf;	// Saved registers
+    // Saved registers: 用户环境暂停时，所有重要的寄存器的值
+	struct Trapframe env_tf;
 	struct Env *env_link;		// Next free Env
 	envid_t env_id;			// Unique environment identifier
 	envid_t env_parent_id;		// env_id of this env's parent
Index: grade-lab3
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#!/usr/bin/env python\n\nfrom gradelib import *\n\nr = Runner(save(\"jos.out\"),\n           stop_breakpoint(\"readline\"))\n\n@test(10)\ndef test_divzero():\n    r.user_test(\"divzero\")\n    r.match('Incoming TRAP frame at 0xefffff..',\n            'TRAP frame at 0xf.......',\n            '  trap 0x00000000 Divide error',\n            '  eip  0x008.....',\n            '  ss   0x----0023',\n            '.00001000. free env 00001000',\n            no=['1/0 is ........!'])\n\n@test(10)\ndef test_softint():\n    r.user_test(\"softint\")\n    r.match('Welcome to the JOS kernel monitor!',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000d General Protection',\n            '  eip  0x008.....',\n            '  ss   0x----0023',\n            '.00001000. free env 0000100')\n\n@test(10)\ndef test_badsegment():\n    r.user_test(\"badsegment\")\n    r.match('Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000d General Protection',\n            '  err  0x00000028',\n            '  eip  0x008.....',\n            '  ss   0x----0023',\n            '.00001000. free env 0000100')\n\nend_part(\"A\")\n\n@test(5)\ndef test_faultread():\n    r.user_test(\"faultread\")\n    r.match('.00001000. user fault va 00000000 ip 008.....',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000e Page Fault',\n            '  err  0x00000004.*',\n            '.00001000. free env 0000100',\n            no=['I read ........ from location 0!'])\n\n@test(5)\ndef test_faultreadkernel():\n    r.user_test(\"faultreadkernel\")\n    r.match('.00001000. user fault va f0100000 ip 008.....',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000e Page Fault',\n            '  err  0x00000005.*',\n            '.00001000. free env 00001000',\n            no=['I read ........ from location 0xf0100000!'])\n\n@test(5)\ndef test_faultwrite():\n    r.user_test(\"faultwrite\")\n    r.match('.00001000. user fault va 00000000 ip 008.....',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000e Page Fault',\n            '  err  0x00000006.*',\n            '.00001000. free env 0000100')\n\n@test(5)\ndef test_faultwritekernel():\n    r.user_test(\"faultwritekernel\")\n    r.match('.00001000. user fault va f0100000 ip 008.....',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000e Page Fault',\n            '  err  0x00000007.*',\n            '.00001000. free env 0000100')\n\n@test(5)\ndef test_breakpoint():\n    r.user_test(\"breakpoint\")\n    r.match('Welcome to the JOS kernel monitor!',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x00000003 Breakpoint',\n            '  eip  0x008.....',\n            '  ss   0x----0023',\n            no=['.00001000. free env 00001000'])\n\n@test(5)\ndef test_testbss():\n    r.user_test(\"testbss\")\n    r.match('Making sure bss works right...',\n            'Yes, good.  Now doing a wild write off the end...',\n            '.00001000. user fault va 00c..... ip 008.....',\n            '.00001000. free env 0000100')\n\n@test(5)\ndef test_hello():\n    r.user_test(\"hello\")\n    r.match('.00000000. new env 00001000',\n            'hello, world',\n            'i am environment 00001000',\n            '.00001000. exiting gracefully',\n            '.00001000. free env 00001000',\n            'Destroyed the only environment - nothing more to do!')\n\n@test(5)\ndef test_buggyhello():\n    r.user_test(\"buggyhello\")\n    r.match('.00001000. user_mem_check assertion failure for va 00000001',\n            '.00001000. free env 00001000')\n\n@test(5)\ndef test_buggyhello2():\n    r.user_test(\"buggyhello2\")\n    r.match('.00001000. user_mem_check assertion failure for va 0....000',\n            '.00001000. free env 00001000',\n            no=['hello, world'])\n\n@test(5)\ndef test_evilhello():\n    r.user_test(\"evilhello\")\n    r.match('.00001000. user_mem_check assertion failure for va f0100...',\n            '.00001000. free env 00001000')\n\nend_part(\"B\")\n\nrun_tests()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/grade-lab3 b/grade-lab3
--- a/grade-lab3	(revision a9d7717cc4b7751b1ce8dca4e5aa2722fa617f6b)
+++ b/grade-lab3	(date 1637155150099)
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python2.7
 
 from gradelib import *
 
